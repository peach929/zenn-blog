---
title: "Google ADKã¨Gemini 2.5 Proã§ä½œã‚‹ä¸–ç•Œã®è¦³å…‰åœ°æ¡ˆå†…AIã‚¢ãƒ—ãƒª" # è¨˜äº‹ã®ã‚¿ã‚¤ãƒˆãƒ«
emoji: "ğŸŒ" # ã‚¢ã‚¤ã‚­ãƒ£ãƒƒãƒã¨ã—ã¦ä½¿ã‚ã‚Œã‚‹çµµæ–‡å­—ï¼ˆ1æ–‡å­—ã ã‘ï¼‰
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢è¨˜äº‹
topics: ["nextjs", "python", "gemini", "googlecloud", "ai"] # ã‚¿ã‚°ã€‚["markdown", "rust", "aws"]ã®ã‚ˆã†ã«æŒ‡å®šã™ã‚‹
published: true # å…¬é–‹è¨­å®šï¼ˆfalseã«ã™ã‚‹ã¨ä¸‹æ›¸ãï¼‰
---

# ã¯ã˜ã‚ã«

ã“ã®è¨˜äº‹ã§ã¯ã€Google ADK (Agent Development Kit) ã¨ Gemini 2.5 Pro ã‚’æ´»ç”¨ã—ã¦ã€ä¸–ç•Œä¸­ã®è¦³å…‰åœ°ã‚’æ¡ˆå†…ã™ã‚‹ AI ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã—ãŸéç¨‹ã‚’ç´¹ä»‹ã—ã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒ AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨å¯¾è©±ã™ã‚‹ã ã‘ã§ã€è¦³å…‰åœ°ã®æƒ…å ±ã‚’å–å¾—ã—ã€Google Maps ã¨ Street View ã§ç¾åœ°ã‚’ç–‘ä¼¼ä½“é¨“ã§ãã‚‹ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚

# ãƒ‡ãƒ¢

ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã€Œæ±äº¬ã®æœ‰åãªè¦³å…‰åœ°ã‚’æ•™ãˆã¦ã€ã¨å…¥åŠ›ã™ã‚‹ã¨ã€AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒè¤‡æ•°ã®è¦³å…‰åœ°ã‚’ç´¹ä»‹ã—ã€ãã‚Œãã‚Œã®åº§æ¨™ã‚’è‡ªå‹•å–å¾—ã€‚åœ°å›³ä¸Šã«ãƒãƒ¼ã‚«ãƒ¼ãŒè¡¨ç¤ºã•ã‚Œã€Street View ã§ç¾åœ°ã®é›°å›²æ°—ã‚’ç¢ºèªã§ãã¾ã™ã€‚

# æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯

## ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰

- **Python 3.x**
- **FastAPI**: Web ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯
- **Google ADK**: AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–‹ç™ºã‚­ãƒƒãƒˆ
- **Gemini 2.5 Pro**: LLM ãƒ¢ãƒ‡ãƒ«
- **Google Maps Geocoding API**: åº§æ¨™å–å¾—

## ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰

- **Next.js 14+** (App Router)
- **React 18+**
- **TypeScript**
- **shadcn/ui**: UI ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
- **@vis.gl/react-google-maps**: Google Maps React ãƒ©ã‚¤ãƒ–ãƒ©ãƒª
- **TailwindCSS**: ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°

## ãƒ‡ãƒ—ãƒ­ã‚¤

- **Google Cloud Platform**
- **Docker**: ã‚³ãƒ³ãƒ†ãƒŠåŒ–

# ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚         â”‚              â”‚
â”‚  Next.js UI  â”‚ â—„â”€SSEâ”€â”€â–ºâ”‚FastAPI Serverâ”‚
â”‚  (Frontend)  â”‚         â”‚  + ADK       â”‚
â”‚              â”‚         â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                        â”‚
       â”‚                        â”‚
       â–¼                        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              â”‚         â”‚              â”‚
â”‚ Google Maps  â”‚         â”‚ Gemini 2.5   â”‚
â”‚     API      â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”¤     Pro      â”‚
â”‚              â”‚         â”‚              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

# å®Ÿè£…ã®è©³ç´°

## 1. ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰: AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®Ÿè£…

### ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å®šç¾©

Google ADK ã‚’ä½¿ç”¨ã—ã¦ã€è¦³å…‰ã‚¬ã‚¤ãƒ‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å®Ÿè£…ã—ã¾ã—ãŸã€‚é‡è¦ãªã®ã¯ã€è¦³å…‰åœ°ã‚’ç´¹ä»‹ã™ã‚‹éš›ã« **å¿…ãšåº§æ¨™ã‚’å–å¾—ã™ã‚‹** ã¨ã„ã†åˆ¶ç´„ã‚’ instruction ã«çµ„ã¿è¾¼ã‚“ã ã“ã¨ã§ã™ã€‚

```python:agent.py
import os
import requests
from urllib.parse import quote
from google.adk.agents.llm_agent import Agent

GOOGLE_MAP_API_KEY = os.environ.get("GOOGLE_MAP_API_KEY")

def google_maps(place: str) -> dict:
    """
    å…¥åŠ›æƒ…å ±ã‹ã‚‰åº§æ¨™ã‚’å–å¾—ã—è¿”ã™ãƒ„ãƒ¼ãƒ«
    Args:
        place (str): å ´æ‰€ã®åå‰ã‚„ä½æ‰€
    Returns:
        dict: ãƒ„ãƒ¼ãƒ«åã€å ´æ‰€ã€åº§æ¨™ã‚’å«ã‚€è¾æ›¸
    """
    encoded_place = quote(place)
    url = f'https://maps.googleapis.com/maps/api/geocode/json?address={encoded_place}&key={GOOGLE_MAP_API_KEY}'

    response = requests.get(url)
    data = response.json()

    if data.get("status") == "OK" and data.get("results"):
        location = data["results"][0]["geometry"]["location"]
        return {
            "tool_name": "google_maps",
            "place": place,
            "lat_lng": f"{location['lat']},{location['lng']}"
        }

    return None

root_agent = Agent(
    model='gemini-2.5-pro',
    name='root_agent',
    description="ä¸–ç•Œã‚’æ¡ˆå†…ã™ã‚‹è¦³å…‰ã‚¬ã‚¤ãƒ‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ",
    instruction="""
        ã‚ãªãŸã¯ä¸–ç•Œã‚’æ¡ˆå†…ã™ã‚‹ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§ã™ã€‚åˆ©ç”¨è€…ã‹ã‚‰ã®è¦æœ›ã«å¿œã˜ã¦ã€
        è©²å½“ã™ã‚‹å ´æ‰€ã€æ­´å²ã€è¦‹ã©ã“ã‚ã€ã‚¢ã‚¯ã‚»ã‚¹æ–¹æ³•ã€ç¾åœ°ã®æ–‡åŒ–ãªã©ã«ã¤ã„ã¦
        è©³ã—ãèª¬æ˜ã—ã¦ãã ã•ã„ã€‚

        ã€é‡è¦ãªãƒ«ãƒ¼ãƒ«ã€‘
        è¦³å…‰åœ°ã‚„å ´æ‰€ã«ã¤ã„ã¦å›ç­”ã™ã‚‹éš›ã¯ã€ç´¹ä»‹ã™ã‚‹ã™ã¹ã¦ã®å ´æ‰€ã«ã¤ã„ã¦
        å¿…ãš google_maps ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—ã¦åº§æ¨™ã‚’å–å¾—ã—ã¦ãã ã•ã„ã€‚
        ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã•ãšã«å ´æ‰€ã‚’ç´¹ä»‹ã™ã‚‹ã“ã¨ã¯ç¦æ­¢ã§ã™ã€‚
        è¤‡æ•°ã®å ´æ‰€ã‚’ç´¹ä»‹ã™ã‚‹å ´åˆã¯ã€ãã‚Œãã‚Œã®å ´æ‰€ã«ã¤ã„ã¦
        å€‹åˆ¥ã«google_mapsãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã—ã¦ãã ã•ã„ã€‚

        è‡ªç„¶ãªä¼šè©±å½¢å¼ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚
    """,
    tools=[google_maps]
)
```

### ãƒã‚¤ãƒ³ãƒˆ

1. **ãƒ„ãƒ¼ãƒ«ã®å¼·åˆ¶å®Ÿè¡Œ**: instruction ã§ã€Œå¿…ãš google_maps ãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã™ã€ã¨æ˜è¨˜ã™ã‚‹ã“ã¨ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåº§æ¨™ã‚’å–å¾—ã›ãšã«è¦³å…‰åœ°ã‚’ç´¹ä»‹ã™ã‚‹ã“ã¨ã‚’é˜²ã„ã§ã„ã¾ã™ã€‚

2. **Geocoding API ã®æ´»ç”¨**: Google Maps Geocoding API ã‚’ä½¿ç”¨ã—ã¦ã€å ´æ‰€ã®åå‰ã‹ã‚‰ç·¯åº¦çµŒåº¦ã‚’å–å¾—ã—ã¦ã„ã¾ã™ã€‚

3. **æ§‹é€ åŒ–ã•ã‚ŒãŸãƒ¬ã‚¹ãƒãƒ³ã‚¹**: ãƒ„ãƒ¼ãƒ«ã¯ `tool_name`, `place`, `lat_lng` ã‚’å«ã‚€è¾æ›¸ã‚’è¿”ã™ã“ã¨ã§ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§ã®å‡¦ç†ã‚’å®¹æ˜“ã«ã—ã¦ã„ã¾ã™ã€‚

### FastAPI ã‚µãƒ¼ãƒãƒ¼ã®èµ·å‹•

```python:main.py
import os
from fastapi import FastAPI
from google.adk.cli.fast_api import get_fast_api_app

AGENT_DIR = os.path.dirname(os.path.abspath(__file__))

ALLOWED_ORIGINS = [
    "http://localhost",
    "http://localhost:8000",
    "*",
]
SERVE_WEB_INTERFACE = True

app: FastAPI = get_fast_api_app(
    agents_dir=AGENT_DIR,
    allow_origins=ALLOWED_ORIGINS,
    web=SERVE_WEB_INTERFACE,
)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=int(os.environ.get("PORT", 8080)))
```

ADK ã® `get_fast_api_app` ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¨ã®é€šä¿¡ã«å¿…è¦ãªã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆ`/run_sse` ãªã©ï¼‰ãŒè‡ªå‹•çš„ã«ç”Ÿæˆã•ã‚Œã¾ã™ã€‚

## 2. ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰: Next.js ã§ã® UI å®Ÿè£…

### SSE ã«ã‚ˆã‚‹ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°é€šä¿¡

ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ Server-Sent Events (SSE) ã§ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å—ä¿¡ã™ã‚‹ã“ã¨ã§ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãªå¯¾è©±ä½“é¨“ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚

```typescript:app/api/chat/route.ts
import { NextRequest } from "next/server";

const AGENT_SERVER_URL = process.env.AGENT_SERVER_URL || "http://127.0.0.1:8000";
const APP_NAME = "world_attractions_agent";

export async function POST(req: NextRequest) {
  const body = await req.json();
  const { user_id, session_id, message } = body;

  let currentSessionId = session_id;

  // ã‚»ãƒƒã‚·ãƒ§ãƒ³ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯æ–°è¦ä½œæˆ
  if (!currentSessionId) {
    const sessionRes = await fetch(
      `${AGENT_SERVER_URL}/apps/${APP_NAME}/users/${user_id}/sessions`,
      { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({}) }
    );
    if (!sessionRes.ok) {
      return new Response(JSON.stringify({ error: "Failed to create session" }),
        { status: 500, headers: { "Content-Type": "application/json" } });
    }
    const session = await sessionRes.json();
    currentSessionId = session.id;
  }

  // ADK ã® /run_sse ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
  const sseRes = await fetch(`${AGENT_SERVER_URL}/run_sse`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      app_name: APP_NAME,
      user_id,
      session_id: currentSessionId,
      new_message: { role: "user", parts: [{ text: message }] },
      streaming: true,
    }),
  });

  // SSEã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã«è»¢é€
  const encoder = new TextEncoder();
  const decoder = new TextDecoder();

  const stream = new ReadableStream({
    async start(controller) {
      controller.enqueue(
        encoder.encode(
          `data: ${JSON.stringify({ type: "session", session_id: currentSessionId })}\n\n`
        )
      );

      const reader = sseRes.body!.getReader();
      let buffer = "";
      try {
        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";

          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;
            controller.enqueue(encoder.encode(line + "\n\n"));
          }
        }
      } finally {
        controller.close();
        reader.releaseLock();
      }
    },
  });

  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}
```

### ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸: ãƒãƒ£ãƒƒãƒˆã¨åœ°å›³ã®çµ±åˆ

```tsx:app/page.tsx
"use client";

import React, { useRef, useState, useCallback } from "react";
import { ChatPanel } from "@/components/chat-panel";
import dynamic from "next/dynamic";
import type { Location } from "@/components/map-panel";

// SSRç„¡åŠ¹åŒ–ï¼ˆGoogle Maps APIã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ã®ã¿ï¼‰
const MapPanel = dynamic(() => import("@/components/map-panel"), { ssr: false });

interface Message {
  id: string;
  role: "user" | "assistant";
  content: string;
}

/**
 * ãƒ„ãƒ¼ãƒ«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‹ã‚‰åº§æ¨™ã‚’æŠ½å‡ºã™ã‚‹
 */
function extractLocationFromTool(
  toolContent: Record<string, unknown>,
): Location | null {
  const name = (toolContent.name as string) || (toolContent.tool_name as string) || "";
  const response = toolContent.response as Record<string, unknown> | undefined;

  const data = response || toolContent;
  const place = (data.place as string) || name;
  const latLng = data.lat_lng as string;

  if (latLng && typeof latLng === "string") {
    const [lat, lng] = latLng.split(",").map(Number);
    if (!isNaN(lat) && !isNaN(lng)) {
      return { id: `tool-${place}-${lat}-${lng}`, name: place, lat, lng };
    }
  }
  return null;
}

export default function Home() {
  const [messages, setMessages] = useState<Message[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [locations, setLocations] = useState<Location[]>([]);
  const [selectedLocationId, setSelectedLocationId] = useState<string | null>(null);
  const [chatOpen, setChatOpen] = useState(true);

  const addLocations = useCallback((newLocations: Location[]) => {
    if (newLocations.length === 0) return;
    const ts = Date.now();
    const stamped = newLocations.map((l, i) => ({ ...l, id: `${l.name}-${ts}-${i}` }));
    setLocations((prev) => [...prev, ...stamped]);
    setSelectedLocationId(stamped[0].id);
  }, []);

  const sendMessage = useCallback(async (text: string) => {
    if (!text.trim() || isLoading) return;

    const userMessage: Message = { id: Date.now().toString(), role: "user", content: text.trim() };
    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);

    const assistantMessageId = (Date.now() + 1).toString();
    setMessages((prev) => [...prev, { id: assistantMessageId, role: "assistant", content: "" }]);

    try {
      const res = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ user_id: "user_web", session_id: sessionId, message: text.trim() }),
      });

      const reader = res.body!.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const chunk = decoder.decode(value);
        const lines = chunk.split("\n").filter((line) => line.trim().startsWith("data: "));

        for (const line of lines) {
          const data = JSON.parse(line.replace(/^data: /, ""));

          if (data.type === "session") {
            setSessionId(data.session_id);
          } else if (data.type === "text") {
            setMessages((prev) =>
              prev.map((msg) =>
                msg.id === assistantMessageId ? { ...msg, content: msg.content + data.text } : msg
              )
            );
          } else if (data.type === "tool") {
            const loc = extractLocationFromTool(data.content);
            if (loc) addLocations([loc]);
          }
        }
      }
    } catch (error) {
      console.error("Error:", error);
    } finally {
      setIsLoading(false);
    }
  }, [isLoading, sessionId, addLocations]);

  return (
    <div className="flex h-screen w-full overflow-hidden">
      {/* Map panel */}
      <div className="flex-1 relative">
        <MapPanel
          locations={locations}
          selectedLocationId={selectedLocationId}
          onSelectLocation={setSelectedLocationId}
        />
      </div>

      {/* Chat panel */}
      <ChatPanel
        messages={messages}
        isLoading={isLoading}
        onSendMessage={sendMessage}
        onNewChat={() => {
          setMessages([]);
          setSessionId(null);
          setLocations([]);
        }}
        open={chatOpen}
        onToggle={() => setChatOpen(!chatOpen)}
      />
    </div>
  );
}
```

### åœ°å›³ãƒ‘ãƒãƒ«ã®å®Ÿè£…

```tsx:components/map-panel.tsx
"use client";

import React, { useEffect } from "react";
import { APIProvider, Map, Marker, useMap } from "@vis.gl/react-google-maps";

export interface Location {
  id: string;
  name: string;
  lat: number;
  lng: number;
}

interface MapPanelProps {
  locations: Location[];
  selectedLocationId: string | null;
  onSelectLocation: (id: string | null) => void;
}

const API_KEY = process.env.NEXT_PUBLIC_GOOGLE_MAP_API_KEY || "";

// åœ°å›³ã®ã‚«ãƒ¡ãƒ©ã‚’é¸æŠã•ã‚ŒãŸãƒ­ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã«åˆã‚ã›ã‚‹ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ
function MapController({ locations, selectedLocationId }: {
  locations: Location[];
  selectedLocationId: string | null;
}) {
  const map = useMap();

  useEffect(() => {
    if (!map) return;

    if (selectedLocationId) {
      const loc = locations.find((l) => l.id === selectedLocationId);
      if (loc) {
        map.panTo({ lat: loc.lat, lng: loc.lng });
        map.setZoom(15);
      }
    } else if (locations.length > 0) {
      // å…¨ãƒãƒ¼ã‚«ãƒ¼ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«ãƒ•ã‚£ãƒƒãƒˆ
      const bounds = new google.maps.LatLngBounds();
      locations.forEach((loc) => bounds.extend({ lat: loc.lat, lng: loc.lng }));
      map.fitBounds(bounds, { top: 50, bottom: 50, left: 50, right: 50 });
    }
  }, [map, locations, selectedLocationId]);

  return null;
}

export default function MapPanel({
  locations,
  selectedLocationId,
  onSelectLocation,
}: MapPanelProps) {
  const defaultCenter = { lat: 35.6762, lng: 139.6503 };
  const center = locations.length > 0
    ? { lat: locations[0].lat, lng: locations[0].lng }
    : defaultCenter;

  return (
    <div className="relative h-full w-full">
      <APIProvider apiKey={API_KEY}>
        <Map
          defaultZoom={locations.length > 0 ? 13 : 4}
          defaultCenter={center}
          gestureHandling="greedy"
          className="h-full w-full"
        >
          <MapController locations={locations} selectedLocationId={selectedLocationId} />
          {locations.map((loc) => (
            <Marker
              key={loc.id}
              position={{ lat: loc.lat, lng: loc.lng }}
              onClick={() => onSelectLocation(loc.id)}
              title={loc.name}
            />
          ))}
        </Map>
      </APIProvider>
    </div>
  );
}
```

# ä¸»è¦ãªå®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ

## 1. ãƒ„ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ«ã®ç¢ºå®Ÿãªå®Ÿè¡Œ

AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ã€Œå¿…ãšåº§æ¨™ã‚’å–å¾—ã™ã‚‹ã€ã¨ã„ã†åˆ¶ç´„ã‚’èª²ã™ã“ã¨ã§ã€ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã§åœ°å›³è¡¨ç¤ºã‚’ç¢ºå®Ÿã«è¡Œãˆã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚instruction ã®æ›¸ãæ–¹ãŒé‡è¦ã§ã™ã€‚

## 2. SSE ã«ã‚ˆã‚‹ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šä¿¡

Server-Sent Events ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã§ã€AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å¿œç­”ã‚’ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ã§å—ä¿¡ã—ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’å‘ä¸Šã•ã›ã¦ã„ã¾ã™ã€‚

## 3. ãƒ„ãƒ¼ãƒ«ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®ãƒ‘ãƒ¼ã‚¹

SSE ã‚¹ãƒˆãƒªãƒ¼ãƒ å†…ã® `tool` ã‚¿ã‚¤ãƒ—ã®ã‚¤ãƒ™ãƒ³ãƒˆã‹ã‚‰åº§æ¨™æƒ…å ±ã‚’æŠ½å‡ºã—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§åœ°å›³ã«åæ˜ ã—ã¦ã„ã¾ã™ã€‚

## ç’°å¢ƒå¤‰æ•°ã®è¨­å®š

- `GOOGLE_MAP_API_KEY`: Google Maps API ã‚­ãƒ¼ï¼ˆãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ï¼‰
- `NEXT_PUBLIC_GOOGLE_MAP_API_KEY`: Google Maps API ã‚­ãƒ¼ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰
- `AGENT_SERVER_URL`: ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚µãƒ¼ãƒãƒ¼ã® URL
- `GOOGLE_APPLICATION_CREDENTIALS`: GCP ã‚µãƒ¼ãƒ“ã‚¹ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚­ãƒ¼

# ãƒãƒã£ãŸãƒã‚¤ãƒ³ãƒˆ

## 1. ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã°ãªã„å•é¡Œ

æœ€åˆã¯ instruction ãŒæ›–æ˜§ã§ã€ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã³å‡ºã•ãªã„ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚**ã€Œå¿…ãšãƒ„ãƒ¼ãƒ«ã‚’å‘¼ã¶ã€ã€Œç¦æ­¢ã€** ãªã©ã®å¼·ã„è¡¨ç¾ã‚’ä½¿ã†ã“ã¨ã§è§£æ±ºã—ã¾ã—ãŸã€‚

## 2. SSE ã®ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°

ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®é€”ä¸­ã§ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ãŒç™ºç”Ÿã—ã€ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ãŒæãªã‚ã‚Œã‚‹ã“ã¨ãŒã‚ã‚Šã¾ã—ãŸã€‚é©åˆ‡ãª HTTP ãƒ˜ãƒƒãƒ€ãƒ¼ï¼ˆ`Cache-Control: no-cache` ãªã©ï¼‰ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§è§£æ±ºã—ã¾ã—ãŸã€‚

## 3. Google Maps ã® SSR å•é¡Œ

Google Maps ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’ SSR ã™ã‚‹ã¨ã€`window` ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¸ã®ã‚¢ã‚¯ã‚»ã‚¹ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã™ã€‚`dynamic import` ã§ `ssr: false` ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§è§£æ±ºã—ã¾ã—ãŸã€‚

# ä»Šå¾Œã®å±•æœ›

- **å¤šè¨€èªå¯¾å¿œ**: Gemini ã®å¤šè¨€èªèƒ½åŠ›ã‚’æ´»ã‹ã—ã¦ã€è¤‡æ•°è¨€èªã§ã®ã‚¬ã‚¤ãƒ‰ã‚’å®Ÿè£…
- **éŸ³å£°å…¥åŠ›**: Web Speech API ã‚’ä½¿ã£ãŸéŸ³å£°ã§ã®è¦³å…‰åœ°æ¤œç´¢
- **ãƒ«ãƒ¼ãƒˆæ¤œç´¢**: è¤‡æ•°ã®è¦³å…‰åœ°ã‚’ç¹‹ããƒ«ãƒ¼ãƒˆã®ææ¡ˆ
- **AR æ©Ÿèƒ½**: ç¾åœ°ã§ã®ARä½“é¨“ã®è¿½åŠ 

# ã¾ã¨ã‚

Google ADK ã¨ Gemini 2.5 Pro ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ç°¡å˜ã«é«˜åº¦ãª AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ§‹ç¯‰ã§ãã¾ã—ãŸã€‚ç‰¹ã«ã€ãƒ„ãƒ¼ãƒ«ã‚³ãƒ¼ãƒ«ã®ä»•çµ„ã¿ã‚’æ´»ç”¨ã™ã‚‹ã“ã¨ã§ã€AI ã®å¿œç­”ã‚’æ§‹é€ åŒ–ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦æ‰±ã„ã€åœ°å›³è¡¨ç¤ºãªã©ã®å®Ÿç”¨çš„ãªæ©Ÿèƒ½ã¨çµ±åˆã§ãã‚‹ç‚¹ãŒé­…åŠ›çš„ã§ã™ã€‚

Next.js ã¨ã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚Šã€ãƒ¢ãƒ€ãƒ³ã§å¿«é©ãª UX ã‚’å®Ÿç¾ã§ãã¾ã—ãŸã€‚çš†ã•ã‚“ã‚‚ãœã²ã€Google ADK ã‚’ä½¿ã£ãŸ AI ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–‹ç™ºã«æŒ‘æˆ¦ã—ã¦ã¿ã¦ãã ã•ã„ï¼

# å‚è€ƒãƒªãƒ³ã‚¯

- [Agent Development Kit](https://google.github.io/adk-docs/)
